# 6. 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

## 동작을 읽기, 쓰기 또는 둘 다로 분류하기

- 읽기
  - 데이터에서 정보를 가져온다.
  - 데이터를 바꾸지 않는다.
- 쓰기
  - 데이터를 바꾼다.
  - 어떤 경우에는 데이터를 바꾸면서 동시에 정보를 가져오는 경우도 있다.

## 카피-온-라이트 원칙 세 단계

1. 복사본 만들기
2. 복사본 변경하기
3. 복사본 리턴하기

**카피-온-라이트는 쓰기를 읽기로 바꾼다. ⇒ 원본 데이터를 바꾸지 않고 정보를 리턴했기 때문!**

```jsx
function add_element_last(array, elem) {
  const new_array = array.slice();
  new_array.push(elem);
  return new_array;
}
```

## 쓰기도 하면서 읽기도 하는 동작은 어떻게 해야하는가?

① 함수를 분리하기

② 값을 두 개 리턴하기

## ① 쓰면서 읽기도 하는 함수를 분리하 기

1. 쓰기에서 읽기를 분리
2. 쓰기에 카피-온-라이트를 적용해 읽기로 바꿈

### 읽기와 쓰기 동작으로 분리하기

- `.shift()` 메서드의 읽기 동작은 값을 단순히 리턴하는 동작
  - `.shift()` 메서드가 리턴하는 값은 배열에 첫 번째 항목
- `.shift()` 메서드의 쓰기 동작은 메서드가 하는 일을 그대로 감싸기만 하면 된다.
  - `.shift()` 메서드의 리턴값은 사용하지 않는다.

```jsx
// 읽기 동작
function first_element(array) {
  return array[0];
}

// 쓰기 동작
function drop_first(array) {
  array.shift();
}
```

### 쓰기 동작을 카피-온-라이트로 바꾸기

- `drop_first()` 함수는 인자로 들어온 값을 변경하는 쓰기이다.

```jsx
function drop_first(array) {
  array.shift();
}

// 카피-온-라이트
function drop_first(array) {
  var array_copy = array.slice(); // 복사
  array_copy.shift(); // 변경
  return array_copy; // 반환
}
```

## ② 값을 두 개 리턴하는 함수로 만들기

1. 새로운 함수로 감싸기
2. 읽기와 쓰기를 함께 하는 함수를 읽기만 하는 함수로 바꿈

### 동작을 감싸기

```jsx
function shift(array) {
  return array.shift();
}
```

### 읽으면서 쓰기도 하는 함수를 읽기 함수로 바꾸기

```jsx
// 카피-온-라이트
function shift(array) {
  var array_copy = array.slice();
  var first = array_copy.shift();
  return {
    first: first,
    array: array_copy,
  };
}
```

## 불변 데이터 구조를 읽는 것은 계산입니다

- 변경 가능한 데이터를 읽는 것은 액션이다.
- 쓰기는 데이터를 변경 가능한 구조로 만든다.
- 어떤 데이터에 쓰기가 없다면 데이터는 변경 불가능한 데이터다.
- 불변 데이터 구조를 읽는 것은 계산이다.
- 쓰기를 읽기로 바꾸면 코드에 계산이 많아진다.

## 불변 데이터 구조는 충분히 빠릅니다

- 언제든 최적화할 수 있다.
  - 속도가 느린 부분이 있다면 그때 최적화
- 가비지 콜렉터는 매우 빠르다.
- 생각보다 많이 복사하지 않는다.
  - 얕은 복사를 하기 때문
  - **얕은 복사**는 데이터 구조의 최상위 단계만 복사하는 것
  - 얕은 복사는 같은 메모리를 가리키는 참조에 대한 복사본을 만드는데 이것을 **구조적 공유**라고 한다.
  - **구조적 공유**
    - 두 중첩된 데이터 구조에서 안쪽 데이터가 같은 데이터를 참조
    - 데이터가 바뀌지 않는 불변 데이터 구조라면 구조적 공유는 안전하다.
    - 메모리를 적게 사용하고, 모든 것을 복사하는 것보다 빠르다.
- 함수형 프로그래밍 언어에는 빠른 구현체가 있다.

## 객체에 대한 카피-온-라이트

객체도 배열에 대한 카피-온-라이트와 같은 단계로 구성되어있다.

다른점은 배열은 `.slice()` 를 사용해 복사본을 만들지만, **객체는 `Object.assign()` 메서드를 사용해 복사본을 만든다.**

```jsx
var object = { a: 1, b: 2 };
var object_copy = Object.assign({}, object);
```

# 7. 신뢰할 수 없는 코드를 쓰면서 불변성 지키기

## 레거시 코드와 불변성

- 레거시 코드
  - 오래전에 만든 것으로, 지금 당장 고칠 수 없어서 그대로 사용해야 하는 코드
  - ⇒ 안전한 인터페이스가 필요함
- 위험성
  - 안전지대 밖으로 나가는 데이터는 잠재적으로 바뀔 수 있다.
    - 신뢰할 수 없는 코드가 데이터를 바꿀 수 있기 때문
  - 신뢰할 수 없는 코드에서 안전지대로 들어오는 데이터도 잠재적으로 바뀔 수 있다.
    - 신뢰할 수 없는 코드가 계속 데이터 참조를 가지고 있기 때문
- 해결책
  - **데이터가 바뀌는 것을 완벽히 막아주는 원칙인 방어적 복사를 사용**

## 우리가 만든 카피-온-라이트 코드는 신뢰할 수 없는 코드와 상호작용해야 합니다

- 카피-온-라이트 방식을 활용하여 데이터 변경을 방지한다.
- 레거시 코드와 상호작용 시 주의
  - 외부에서 데이터 참조가 유지되면 의도치 않은 변경 가능성 있다.
- 방어적 복사를 통해 데이터를 안전하게 유지한다.

## 방어적 복사 규칙

1. 데이터가 안전한 코드에서 나갈 때 복사하기
   - 불변성 데이터를 위한 **깊은 복사본**을 만든다.
   - 신뢰할 수 없는 코드로 복사본을 전달
2. 안전한 코드로 데이터가 들어올 때 복사
   - 변경될 수도 있는 데이터가 들어오면 바로 **깊은 복사본**을 만들어 안전한 코드로 전달
   - 복사본을 안전한 코드에서 사용

이 규칙을 따르면 **불변성 원칙을 지키면서 신뢰할 수 없는 코드와 상호작용할 수 있다.**

## 방어적 복사가 익숙할 수도 있습니다

- 대부분 웹 기반 API는 암묵적으로 방어적 복사를 함
  - JSON 데이터는 깊은 복사본이다.
- 모듈이 서로 통신하기 위해 벙어적 복사를 구현했다면 비공유 아키텍처라고 한다.
  - 모듈이 어떤 데이터의 참조도 공유하고 있지 않기 때문
- 얼랭과 엘릭서에서 방어적 복사

## 카피-온-라이트와 방어적 복사를 비교해 봅시다

|                    | **카피-온-라이트**              | **방어적 복사**                                 |
| ------------------ | ------------------------------- | ----------------------------------------------- |
| **언제 쓰는가?**   | 통제할 수 있는 데이터를 바꿀 때 | 신뢰할 수 없는 코드와 데이터를 주고받아야 할 때 |
| **어디서 쓰는가?** | 안전지대 어디서나 사용 가능     | 안전지대의 경계에서 데이터가 오고 갈 때         |
| **복사 방식**      | 얕은 복사                       | 깊은 복사                                       |

## 깊은 복사는 얕은 복사보다 비쌉니다

- 깊은 복사는 모든 것을 복사하기 때문
  - 원본과 어떤 데이터 구조도 공유하지 않는 것이 얕은 복사와의 차이점이다.
  - 깊은 복사는 모든 곳에 쓰지 않는다.
  - 카피-온-라이트를 사용할 수 없는 곳에서만 사용한다.
